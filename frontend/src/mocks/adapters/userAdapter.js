import {
  mockUserAccounts,
  findUserByUsername,
  addUserAccount,
  updateUserAccount,
  deleteUserAccount,
} from "../data/users";
import { randomDelay, generateId } from "../utils";
import { logger } from "@/utils/logger";

export const mockUserAdapter = {
  /**
   * Get all users
   */
  async getAllUsers() {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Get All Users");

    const data = mockUserAccounts.map(mapUserToContract);
    return {
      message: "Get users successfully",
      success: true,
      total: data.length,
      data,
    };
  },

  /**
   * Get user by ID
   */
  async getUserById(id) {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Get User By ID", { id });

    const user = mockUserAccounts.find((u) => u.employeeid === id);
    if (!user) {
      throw new Error("User not found");
    }

    return {
      message: "Get user successfully",
      success: true,
      data: mapUserToContract(user),
    };
  },

  /**
   * Create new user
   */
  async createUser(userData) {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Create User", { fullName: userData.fullName });

    // Generate employee ID and username (auto-generated by system)
    const employeeId = generateId("EMP");
    const username = employeeId; // Username = Employee ID (e.g., EMP001)
    const defaultPassword = "123456"; // System generates default password

    // Check if username exists (shouldn't happen with generated IDs)
    if (findUserByUsername(username)) {
      throw new Error("Username already exists");
    }

    const newUser = {
      userid: username,
      password: defaultPassword, // System-generated password
      employeeid: employeeId,
      role: userData.role || userData.roleName,
      fullName: userData.fullName,
      email: userData.email,
      branchName: userData.branchName || "Thá»§ Äá»©c",
      status: "active",
      createdDate: new Date().toISOString().split("T")[0],
      lastlogin: null,
    };

    addUserAccount(newUser);

    return {
      message: "Create user successfully",
      success: true,
      data: mapUserToContract(newUser),
    };
  },

  /**
   * Update user by ID
   */
  async updateUser(id, updates) {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Update User", { id, updates });

    const user = mockUserAccounts.find((u) => u.employeeid === id);
    if (!user) {
      throw new Error("User not found");
    }

    // Update user data
    const updatedUser = updateUserAccount(user.userid, {
      fullName: updates.fullName || user.fullName,
      email: updates.email || user.email,
      role: updates.roleName || updates.role || user.role,
      branchName: updates.branchName || user.branchName,
    });

    return {
      message: "Update user successfully",
      success: true,
      data: mapUserToContract(updatedUser),
    };
  },

  /**
   * Update user status by ID
   */
  async updateUserStatus(id, status) {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Update User Status", { id, status });

    const user = mockUserAccounts.find((u) => u.employeeid === id);
    if (!user) {
      throw new Error("User not found");
    }

    const updatedUser = updateUserAccount(user.userid, { status });
    return {
      message: "Update user status successfully",
      success: true,
      data: mapUserToContract(updatedUser),
    };
  },

  /**
   * Delete user by ID
   * Note: mock-only. DELETE is not implemented in OpenAPI; kept for testing.
   */
  async deleteUser(id) {
    await randomDelay();
    logger.info("ðŸŽ­ Mock Delete User", { id });

    const user = mockUserAccounts.find((u) => u.employeeid === id);
    if (!user) {
      throw new Error("User not found");
    }

    const deleted = deleteUserAccount(user.userid);
    if (!deleted) {
      throw new Error("Failed to delete user");
    }

    return {
      success: true,
      message: "Delete user successfully",
    };
  },
};

function mapUserToContract(user) {
  // Only contract fields; anything else should be marked as mock-extension if ever added
  return {
    id: user.employeeid,
    username: user.userid,
    fullName: user.fullName,
    email: user.email,
    roleName: user.role,
    branchName: user.branchName,
    status: user.status,
    createdAt: user.createdDate,
  };
}
